#include <Wire.h>
#include <MPU9250_asukiaaa.h>
#include <SoftwareSerial.h>

// --- Modules ---
SoftwareSerial lora(6, 5);       // LoRa RX=6, TX=5
SoftwareSerial mySerial(2, 3);   // GSM RX=2, TX=3

MPU9250_asukiaaa mySensor;

unsigned long notWornConfirmStart = 0;       // Timer to confirm not worn
const unsigned long notWornConfirmDelay = 2000; // 2 seconds
bool notWornPending = false;                 // Flag if not worn is pending

// --- Pins ---
#define MIC_PIN A1
#define GAS_PIN A0
#define LED_PIN 13
#define CANCEL_BTN1 7
#define CANCEL_BTN2 8
#define LIMIT_SWITCH1 10
#define LIMIT_SWITCH2 11
#define LIMIT_SWITCH3 12
#define RELAY_PIN 9
#define VIBRATION_MOTOR 13

// --- Thresholds ---
const int micThreshold = 700;
const int gasThreshold = 300;
const float motionThreshold = 0.40;

// --- Timing ---
const unsigned long micCheckDuration = 3000;
const unsigned long cancelDuration = 5000;
const unsigned long gasAlertInterval = 120000;
const unsigned long motionTimeout = 5000;
const unsigned long notWornTimeout = 5000;
const unsigned long relayDelay = 60000;
const unsigned long vibrationInterval = 500;

// --- Globals ---
bool motionDetected = false;
unsigned long motionStartTime = 0;
bool cancelTimerActive = false;
unsigned long cancelStartTime = 0;
bool cancelPressed = false;
String fallType = "";
const char phoneNumber[] = "+919372340395";

int consecutiveAbove = 0;
int maxConsecutiveAbove = 0;
unsigned long lastGasAlertTime = 0;
unsigned long notWornStartTime = 0;
bool relayActivated = false;
String lastState = "";
bool monitoringActive = false;
unsigned long vibrationPreviousMillis = 0;
bool vibrationState = false;
unsigned long improperStartTime = 0;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(CANCEL_BTN1, INPUT_PULLUP);
  pinMode(CANCEL_BTN2, INPUT_PULLUP);
  pinMode(LIMIT_SWITCH1, INPUT_PULLUP);
  pinMode(LIMIT_SWITCH2, INPUT_PULLUP);
  pinMode(LIMIT_SWITCH3, INPUT_PULLUP);
  pinMode(RELAY_PIN, OUTPUT);
  pinMode(VIBRATION_MOTOR, OUTPUT);

  digitalWrite(RELAY_PIN, LOW);
  digitalWrite(VIBRATION_MOTOR, LOW);

  Serial.begin(115200);
  lora.begin(115200);
  Wire.begin();
  mySensor.setWire(&Wire);
  mySensor.beginAccel();
  mySensor.beginGyro();
  mySerial.begin(9600);

  Serial.println("Helmet System with LoRa Ready");
  sendGSMCommand("AT");
  sendGSMCommand("AT+CMGF=1"); // SMS mode
}

void loop() {
  mySensor.accelUpdate();
  float axx = abs(mySensor.accelX());
  float ayy = abs(mySensor.accelY());
  bool helmetMotion = (axx >= motionThreshold || ayy >= motionThreshold);

  int micValue = analogRead(MIC_PIN);
  int gasValue = analogRead(GAS_PIN);

  bool s1 = digitalRead(LIMIT_SWITCH1) == LOW;
  bool s2 = digitalRead(LIMIT_SWITCH2) == LOW;
  bool s3 = digitalRead(LIMIT_SWITCH3) == LOW;
  int pressedCount = s1 + s2 + s3;

  String stateToSend = "";

  // --- HELMET STATE LOGIC ---
 if (!monitoringActive) {
    if (pressedCount == 3 && helmetMotion) {
        // Properly worn
        Serial.println("Helmet properly worn");
        stopVibration();
        digitalWrite(RELAY_PIN, LOW);
        relayActivated = false;
        improperStartTime = 0;
        notWornStartTime = 0;

        // Reset not worn confirmation
        notWornPending = false;
        notWornConfirmStart = 0;

        stateToSend = "worn";
    } 
    else if (pressedCount >= 1 && pressedCount <= 2) {
        // Improperly worn
        Serial.println("Helmet worn improperly");
        handleImproperHelmet(true);

        // Reset not worn confirmation
        notWornPending = false;
        notWornConfirmStart = 0;

        stateToSend = "improper";
    } 
   else {
    // No switches pressed
    if (!notWornPending) {
        notWornPending = true;
        notWornConfirmStart = millis();  // start 2-second timer

        // Immediately stop vibration when not worn timer starts
        stopVibration();
    }

    if (millis() - notWornConfirmStart >= notWornConfirmDelay) {
        handleImproperHelmet(false);
        handleHelmetNotWorn();
        stateToSend = "no";
    }
}


    // --- Send state over LoRa if changed ---
    if (stateToSend != "" && stateToSend != lastState) {
        sendLoRa(stateToSend);
        lastState = stateToSend;
    }

    // --- Always run fall detection ---
    fall_detect(gasValue, micValue);
} 
else {
    fall_detect(gasValue, micValue);
}

  delay(10);
}

// --- HELPER FUNCTIONS ---

void stopVibration() {
  digitalWrite(VIBRATION_MOTOR, LOW);
  vibrationState = false;
}

void handleImproperHelmet(bool switchPressed) {
    unsigned long currentMillis = millis();

    if (switchPressed) {
        // Start vibration toggle if interval passed
        if (currentMillis - vibrationPreviousMillis >= vibrationInterval) {
            vibrationPreviousMillis = currentMillis;
            vibrationState = !vibrationState;
            digitalWrite(VIBRATION_MOTOR, vibrationState ? HIGH : LOW);
        }
    } else {
        // Helmet no longer improper, stop vibration
        stopVibration();
    }

    // Do not reset timers or stop vibration automatically
    relayActivated = false;
}


void handleHelmetNotWorn() {
  if (notWornStartTime == 0) notWornStartTime = millis();  // Set only once

  unsigned long elapsed = millis() - notWornStartTime;

  if (elapsed < notWornTimeout) {
    Serial.println("Helmet not worn (grace period)");
    stopVibration();
  } else {
    Serial.println("Helmet not worn");
    stopVibration();

    if (!relayActivated && elapsed >= relayDelay) {
      digitalWrite(RELAY_PIN, HIGH);
      Serial.println("Relay activated due to helmet not worn for 60 sec");
      relayActivated = true;
    }
  }
}


void sendLoRa(String msg) {
  String cmd = "AT+SEND=0," + String(msg.length()) + "," + msg + "\r\n";
  lora.print(cmd);
  Serial.println("LoRa Sent: " + cmd);
}

void startCancelTimer() {
  cancelTimerActive = true;
  cancelStartTime = millis();
  cancelPressed = false;
  Serial.println("Cancel window started - Press both buttons to cancel alert");
}

void transmitFallType(String type) {
  String cmd = "AT+SEND=0," + String(type.length()) + "," + type + "\r\n";
  lora.print(cmd);
  Serial.println("LoRa Sent: " + cmd);
}

void executeAlert(String type) {
  if (type == "HARD") callNumber(phoneNumber);
  else if (type == "MIDDLE") sendSMS("Fall detected: MIDDLE");
  else Serial.println("No alert for SOFT or undefined");
  triggerAlert();
}

void triggerAlert() {
  delay(3000);
  digitalWrite(LED_PIN, LOW);
}

void sendSMS(String msg) {
  mySerial.println("AT+CMGS=\"" + String(phoneNumber) + "\"");
  delay(500);
  mySerial.print(msg);
  delay(500);
  mySerial.write(26); // Ctrl+Z
  delay(500);
  Serial.println("SMS Sent: " + msg);
}

void callNumber(const char *number) {
  mySerial.print("ATD");
  mySerial.print(number);
  mySerial.println(";");
  Serial.println("Calling " + String(number));
  delay(20000);
  mySerial.println("ATH");
  Serial.println("Call ended");
}

void sendGSMCommand(String cmd) {
  mySerial.println(cmd);
  delay(500);
  while (mySerial.available()) Serial.write(mySerial.read());
}

void fall_detect(int gasValue, int micValue) {
  float ax = mySensor.accelX();
  float ay = mySensor.accelY();
  float az = mySensor.accelZ();
  float accelMag = sqrt(ax*ax + ay*ay + az*az);
  int AM = accelMag * 10;

  Serial.print("AM: "); Serial.print(AM);
  Serial.print(" | GAS: "); Serial.print(gasValue);
  Serial.print(" | MIC: "); Serial.println(micValue);

  unsigned long now = millis();
  if (gasValue > gasThreshold) {
    digitalWrite(LED_PIN, HIGH);
    delay(500);
    digitalWrite(LED_PIN, LOW);
    delay(500);
    if (now - lastGasAlertTime >= gasAlertInterval) {
      sendSMS("GAS Detected");
      lastGasAlertTime = now;
      Serial.println("GAS detected - SMS sent");
    }
  }

  if (AM > 20 && !motionDetected && !cancelTimerActive) {
    motionDetected = true;
    monitoringActive = true;
    motionStartTime = millis();
    consecutiveAbove = 0;
    maxConsecutiveAbove = 0;
    Serial.println("Motion detected - Start mic monitoring");
    stopVibration();
  }

  if (motionDetected) {
    if (millis() - motionStartTime <= micCheckDuration) {
      micValue = analogRead(MIC_PIN);
      if (micValue > micThreshold) {
        consecutiveAbove++;
        if (consecutiveAbove > maxConsecutiveAbove) maxConsecutiveAbove = consecutiveAbove;
      } else consecutiveAbove = 0;
    } else {
      if (maxConsecutiveAbove >= 5) fallType = "HARD";
      else if (maxConsecutiveAbove == 4 || maxConsecutiveAbove == 3) fallType = "MIDDLE";
      else if (maxConsecutiveAbove == 2) fallType = "SOFT";
      else fallType = "";

      if (fallType != "") {
        Serial.print("Fall detected: "); Serial.println(fallType);
        digitalWrite(LED_PIN, HIGH);
        startCancelTimer();
      }

      motionDetected = false;
      consecutiveAbove = 0;
      maxConsecutiveAbove = 0;
    }
  }

  if (cancelTimerActive) {
    if (digitalRead(CANCEL_BTN1) == LOW && digitalRead(CANCEL_BTN2) == LOW) {
      cancelPressed = true;
      Serial.println("Cancel pressed!");
      digitalWrite(LED_PIN, LOW);
    }

    if (millis() - cancelStartTime >= cancelDuration) {
      cancelTimerActive = false;
      monitoringActive = false;
      if (!cancelPressed && fallType != "") {
        digitalWrite(LED_PIN, LOW);
        transmitFallType(fallType);
        executeAlert(fallType);
      } else {
        Serial.println("Alert cancelled.");
        digitalWrite(LED_PIN, LOW);
      }
    }
  }
}
